/*
  Проект "Металлический робот"
  Автор
    Зубр ОВК
  Описание
    Исполнение для правой руки
    Скрипт, с помощью которого выполняется "баскетбольный бросок"

    Данный скрипт использует новую возможность прошивки движков с 21-битным энкодером
    управлять непосредственно шим-ом, а также "на лету" переключаться между режимами
    управления "шим" и "по углу".

    Идея в следующем: для управления мы используем очереди, ассоциированные с каждым движком.
    Размер этих очередей - 256 значений, что дает возможность записать траекторию длительностью
    2.5 сек при периоде фреймов 10мс.

    В начале каждого фрейма из очереди, ассоциированной с конкретным движком извлекается очередное
    значение управления и отправляется в движок.

    Для помещения значений в очередь используются функции sfPlay...
    sfPlaySamples и sfPlayWSamples позволяют разместить в очереди значения из списков cblock и cwblock соответственно.
    Значения интерпретируются как приращения к предыдущему значению. Начальное значение также передается в эти функции.

    Функция sfPlaySample помещает в очередь одно или несколько копий одного и того-же значения.

    Функция sfPlayISamples помещает в очередь значения из массива.

    Значения размещенные в очереди интерпретируются в зависимости от текущего регулятора. По умолчанию в качестве текущего
    регулятора используется регулятор угла. Поэтому по умолчанию эти значения будут интерпретироваться как очередные позиции,
    в которые нужно встать движку.

    Отправляя специальный код значения SV_MOTOR_PWM_ON и SV_MOTOR_PWM_OFF мы можем включить и выключить интерпретацию
    значений как ШИМ-значений, которые непосредственно подаются на ШИМ-формирователь.

    Поэтому, алгоритм баскетбольного броска выглядит так:
    - подготовить ШИМ-траектории в массивах для каждого из движков, участвующих в броске
    - далее, последовательно размещаем в очереди следующие коды:
       - переключение интерпретации значений на ШИМ
       - массив ШИМ-траектории
       - переключение интерпретации значений на углы
    и, после этого ждем количество фреймов, равное количеству значений размещенных в очередях.
*/

#include <roki2met.h>

int pitStop;
int startStop;
int distance;
int direction;
int frameCount;

void page13(){
  frameCount = 200;
  sfPoseGroup( MASK_RIGHT_CLAVICLE, 4096, frameCount );
  sfPoseGroup( MASK_RIGHT_ELBOW, 537, frameCount );
  sfPoseGroup( MASK_RIGHT_SHOULDER, 7219, frameCount );
  sfPoseGroup( MASK_RIGHT_ELBOW_SIDE, 0, frameCount );
  sfPoseGroup( MASK_HEAD_ROTATE, -188, frameCount );
  sfPoseGroup( MASK_TORSO_ROTATE, 420, frameCount );
  sfWaitFrame( frameCount );
}

void page14(){
  frameCount = 400;
  sfPoseGroup( MASK_RIGHT_ELBOW, -1000 + distance, frameCount ); //-550
  sfPoseGroup( MASK_RIGHT_ELBOW_SIDE, - direction, frameCount );
  sfWaitFrame( frameCount );
}

void page15(){
  frameCount = 8;
  sfPoseGroup( MASK_RIGHT_ELBOW, 1730 + distance, frameCount );
  sfPoseGroup( MASK_RIGHT_CLAVICLE, 1365, frameCount );
  sfWaitFrame( frameCount );
}


//Исходные ШИМ-траектории. При необходимости нужно подобрать для оптимального броска
cwblock cbPwmElbow = { 600 1300 1900 1900 1900 1900 1900 1900 1900 1900 1900 1273 937 663 394 261 261 171 114 124 65 13 9 0 0 0 0 0 0 0 };
cwblock cbPwmClavicle = { -300 -800 -1500 -1900 -1900 -1900 -1900 -1900 -1900 -1164 -920 -739 -624 -574 -506 -467 -438 -339 -292 -292 -175 -191 -205 -138 -158 -119 -116 -157 -136 -140 };

//Массивы для ШИМ-траекторий
int pwmElbow[30];
int pwmClavicle[30];
int i;      //Переменная цикла
int multer; //Множитель для ШИМ-траекторий


void page15pwm() {
  //Сначала копируем исходные ШИМ-траектории в массивы
  sfCopyBlock( &cbPwmElbow, &(pwmElbow[0]), 30 );
  sfCopyBlock( &cbPwmClavicle, &(pwmClavicle[0]), 30 );
  
  //Теперь корректируем ШИМ-траектории путем умножения на множитель
  //Деление на 1000 - для организации дробного множителя
  for( i = 0; i < 30; i++ ) {
    pwmElbow[i] = pwmElbow[i] * multer / 1000;
    pwmClavicle[i] = pwmClavicle[i] * multer / 1000;
    }
  
  //Далее размещаем в очередях
  //  - переключение интерпретации значений на ШИМ
  sfPlaySample( MASK_RIGHT_ELBOW | MASK_RIGHT_CLAVICLE, SV_MOTOR_PWM_ON, 3 );
  //  - массивы ШИМ-траектории
  sfPlayISamples( MASK_RIGHT_ELBOW, &(pwmElbow[0]), 30 );
  sfPlayISamples( MASK_RIGHT_CLAVICLE, &(pwmClavicle[0]), 30 );
  // - переключение интерпретации значений на углы
  sfPlaySample( MASK_RIGHT_ELBOW | MASK_RIGHT_CLAVICLE, SV_MOTOR_PWM_OFF, 3 );
  //Ожидаем, когда закончится исполнение траекторий (не полностью)
  sfWaitFrame( 34 );
  //Размещаем в очереди углы, которые нужно удерживать
  //Когда ШИМ-траектория проиграется, движки окажутся в некоторых позициях
  //экспериментально выяснено, что конкретно в этих позициях
  //Поэтому мы ставим эти углы. Если этого не сделать, то в двигатель
  //будут передаваться последние коды из ШИМ последовательностей, но
  //они уже будут интерпретироваться как углы и двигатели начнут движение к этим углам
  //а нам этого не нужно. Поэтому мы в заключение даем углы, на которых движки уже стоят
  //поэтому никакого движения не происходит
//  sfPlaySample( MASK_RIGHT_ELBOW, 2286, 3 );
//  sfPlaySample( MASK_RIGHT_CLAVICLE, 1536, 3 );
  sfPlaySample( MASK_RIGHT_ELBOW, rightElbowCurrent, 3 );
  sfPlaySample( MASK_RIGHT_CLAVICLE, rightClavicleCurrent, 3 );
  sfWaitFrame( 6 );
  
  //Замечание. Для переключений даются несколько одинаковых значений. В частности 3шт. Это здесь  |
  //                         sfPlaySample( MASK_LEFT_ELBOW | MASK_LEFT_CLAVICLE, SV_MOTOR_PWM_ON, 3 );
  //Нужно это потому, что передача управляющих воздействий в движок происходит без подтверждений.
  //Поэтому есть вероятность, что конкретное единственное значение может не дойти. Поэтому мы
  //на всякий случай делаем три попытки.
  }

void page16(){
  frameCount = 12;
  sfPoseGroup( MASK_RIGHT_ELBOW, 3000, frameCount );
  sfPoseGroup( MASK_RIGHT_CLAVICLE, 0, frameCount );
  sfWaitFrame( frameCount );
}

void page17(){
  frameCount = 100;
  sfPoseGroup( MASK_ALL, 0, frameCount );
  sfWaitFrame( frameCount );
}


void main(){
  frameCount = 1;
  pitStop = 0;
  startStop = 0;
  distance = -500;
  direction = 200;
 // while (pitStop == 0) sfWaitFrame(1); // waiting to change parameters
  page13();
  while (startStop == 0) sfWaitFrame(1); // waiting to change parameters
  
  //Здесь мы вычисляем множитель как линейную зависимость от напряжения питания.
  //Эксперименты показали, что линейная зависимость сохраняется только до определенного напряжения
  //Затем она становится нелинейной. Вероятно, когда результат умножения становится больше
  //максимального значения ШИМ. Решить эту проблему можно двумя способами:
  // 1. Снизить значения исходной траектории, чтобы значения, будучи умноженными на множитель
  //    не превышали максимально возможного значения шим.
  // 2. Для нелинейной части организовать кусочно-линейную апроксимацию, т.е. считать множитель по
  //    другой формуле (т.е. формула та-же, но числа будут другие)
  multer = (3250 - svAdc) * 90 / 263 + 1000;
  
  page14();

  sfAccumSetup4( &leftElbowCurrent, &leftElbowPwm, &leftClavicleCurrent, &leftClaviclePwm );
  sfAccumTrigger();
  
  page15pwm();
  //page16();
  page17();
  
  sfStop();
}
